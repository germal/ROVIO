http://grauonline.de/wordpress/?page_id=1951
https://pixhawk.org/peripherals/onboard_computers/odroid_c1

ROS camera and IMU synchronization
ROS camera mvBlueFox and IMU MU6050 synchronization
The Arduino will calculate precise (millisecond) timestamps for each IMU measurement (200 Hz). 
At certain timestamps (20 Hz), it will trigger the camera (via the trigger line) to capture a new image.

WORKS WITH MPU9250
Because its calling th DMP processor, the code can run on a MPU9250
The main advantage relies in the stable 200 Hz interrupted updates generated by the DMP


INSTALL
Download ROS_bluefox2_mpu6050_synchronization_hack.zip
Extract mpu6050_serial_to_imu to catkin_ws/src
Prereq.:
sudo apt-get install ros-indigo-serial
catkin_make


LAUNCH 
modify demo.launch for ACM port
<param name="port" value="/dev/ttyACM0"/>
to get RVIZ , remove <!-- before the <node rviz in demo.launch

!!!!!!!!!!!!!!
roslaunch mpu6050_serial_to_imu demo.launch 
!!!!!!!!!!!!!


///////////////////////////////////MODS////////////////////////////////////////

Camera External Trigger

Modified MPU6050.ino
 so that pin 5 gets
Inverted camera trigger (PIN 5) because IDS UEYE triggers on Falling Edge
Line 85
#define TRIGGER_PIN 5
 
line 130 == TRIGGER HIGH
void dmpDataReady() {
    irqTimestamp = millis();
    irqCounter++;
    if (irqCounter == 5){ // 40 Hz
      //if (waitCounter < 20){ // only count below 1 sec
        digitalWrite(TRIGGER_PIN, LOW);
        //delayMicroseconds(1);
        digitalWrite(TRIGGER_PIN, HIGH);
        triggerCounter++;
      //}

line 155 = SET BAUD RATE ACCORDING WITH IMU_NODE
    // initialize serial communication
    // (115200 chosen because it is required for Teapot Demo output, but it's
    // really up to you depending on your project)
    //Serial.begin(115200);
    Serial.begin(115200);

line 168 ==SET pinmode - then drive HIGH
    pinMode(TRIGGER_PIN, OUTPUT);
    digitalWrite(TRIGGER_PIN, HIGH);


Installed 10 pins low profile female connector on Ueye-LE 
Ground  PIN2
Trig	PIN3


Created launch file mono_ext_trig.launch wit ext trig
<param name="ext_trigger_mode" type="bool" value="True" 

roslaunch mono_ext_trig.launch
[ INFO] [1520719169.676541665]: [camera] set to external trigger mode

rosrun image_view image_view image:=/camera/image_raw
OK

rostopic hz /camera/image_raw
average rate: 40.019

COOL !!!



=========modification of imu_node.cpp=========================================
KALIBR NOTE
camera-imu calibration    
run calibration
kalibr_calibrate_imu_camera --cam camchain.yaml --target april_6x6.yaml --imu imu.yaml --bag dynamic.bag
ERROR 
Failed to obtain orientation prior. Please make sure that your sensors are synchronized correctly.

RESOLUTION
Looking at timings I saw that IMU was using a different time base
mpu6050_serial_to_imu_node.cpp
Changed line 193
		ros::Time measurement_time = ros::Time::now() + ros::Duration(time_offset_in_seconds);
		//ros::Time measurement_time(ts / 1000, (ts % 1000) * 1000*1000);  // sec, nsec


==================CLIPPING  14 Avril===================
Spurious accel signal is bad == Clip It 

https://stackoverflow.com/questions/9323903/most-efficient-elegant-way-to-clip-a-number
Answer 20 Why rewrite something that's already been written for you?
#include <boost/algorithm/clamp.hpp>
boost::algorithm::clamp(n, lower, upper)


Added  Boost to /home/patrick/catkin_ws/src/mpu6050_serial_to_imu/CMakeLists.txt
# include_directories(include)
include_directories(
  ${catkin_INCLUDE_DIRS}
  ${Boost_INCLUDE_DIRS}
)

Added library - define & code

#include <boost/algorithm/clamp.hpp>
  using boost::algorithm::clamp;

		double min = -8.0;
		double max = 8.0;
                double gxf = clamp ((gx * (4000.0/65536.0) * (M_PI/180.0) * 22.0), min, max);
                double gyf = clamp ((gy * (4000.0/65536.0) * (M_PI/180.0) * 22.0), min, max);
                double gzf = clamp ((gz * (4000.0/65536.0) * (M_PI/180.0) * 22.0), min, max);


/////////////////////////////////////////////////////////////






+++++++++other experiments++++++++++++++++++++

MPU9250_ROS
https://github.com/lennartclaassen/arduino-ros-imu/blob/master/MPU9250_ROS/MPU9250_ROS.ino

Running the node:
rosrun rosserial_python serial_node.py _port:=/dev/ttyACM0 _baud:=115200

Looking at topic:
rostopic echo /imu_msg

================================================================================
Adding STRICT TIMING & CAMERA TRIGGER
https://arduino.stackexchange.com/questions/21582/how-do-you-control-the-amount-of-times-the-void-loop-loops-per-second
#define INTERVAL 500   // time between reads
if (millis() - lastRead >= INTERVAL){  // if INTERVAL has passed

Works ok
rostopic hz /acc
average rate: 199.715 

Add camera tTrigger as per http://grauonline.de/wordpress/?page_id=1951
  count = millis();
  loopCounter++;
    if (loopCounter >= DownScaler){ // value 10 to trigger cam @20 Hz
      //digitalWrite(TRIGGER_PIN, HIGH);
      //digitalWrite(TRIGGER_PIN, LOW);
      digitalWrite(myLed, !digitalRead(myLed)); // toggle led 
      triggerCounter++;
      loopCounter = 0; 
      }

==================DRIFT!!DRIFT!!DRIFT!!===============================================
IMU CALIBRATION
Arduino Sketch to automatically calculate MPU6050 offsets 
https://www.i2cdevlib.com/forums/topic/96-arduino-sketch-to-automatically-calculate-mpu6050-offsets/
http://42bots.com/tutorials/arduino-script-for-mpu-6050-auto-calibration/

---------------TEST APR 7------------
http://www.instructables.com/id/Arduino-driven-Balance-Board/
using this:
https://github.com/chrisspen/homebot/blob/master/reference/parts/MPU6050%20Kootek%20GY-521%20Gyro%20Accel/MPU6050_calibration/MPU6050_calibration.ino

-----------------
https://www.i2cdevlib.com/forums/topic/91-how-to-decide-gyro-and-accelerometer-offsett/
This sketch uses DMP and Output data in YAw pitch Roll or other formats. waits 20 seconds for stability before giving data.
MPU6050_auto_calibration_output_yaw_pitch_roll.ino
Good... but sitll based on the same library....


-------------MU6050_IMUZERO.ino-------------------------
https://github.com/jrowberg/i2cdevlib/blob/master/Arduino/MPU6050/examples/IMU_Zero/IMU_Zero.ino
Put the MPU6050 on a flat and horizontal surface, and leave it operating for 5-10 minutes so its temperature gets stabilized.
Run this program.  A "----- done -----" line will indicate that it has done its best.
With the current accuracy-related constants (NFast = 1000, NSlow = 10000), it will take a few minutes to get there.

Along the way, it will generate a dozen or so lines of output, showing that for each of the 6 desired offsets, it is 
      * first, trying to find two estimates, one too low and one too high, and
      * then, closing in until the bracket can't be made smaller.

The line just above the "done" line will look something like
 [567,567] --> [-1,2]  [-2223,-2223] --> [0,1] [1131,1132] --> [16374,16404] [155,156] --> [-1,1]  [-25,-24] --> [0,3] [5,6] --> [0,4]
As will have been shown in interspersed header lines, the six groups making up this
line describe the optimum offsets for the X acceleration, Y acceleration, Z acceleration,
X gyro, Y gyro, and Z gyro, respectively.  In the sample shown just above, the trial showed
that +567 was the best offset for the X acceleration, -2223 was best for Y acceleration, 
and so on.

--Results 10 Avril--
XAccel			   YAccel	 	   ZAccel			XGyro			YGyro			ZGyro
[-2379,-2378] --> [-4,18]  [-215,-214] -->[-4,10]  [843,844] --> [16370,16392]	[23,24] --> [-1,1]	[39,40] --> [0,3]	[2,3] --> [-2,2]
[-2379,-2378] --> [-4,18]  [-215,-214] -->[-7,10]  [843,844] --> [16363,16392]	[23,24] --> [0,1]	[39,39] --> [0,1]	[2,3] --> [-1,2]
-------------- done --------------
FINAL NUMBERS:
XAccel	-2379		  
YAccel	-215 	   
ZAccel	844		
XGyro	0		
YGyro	2		
ZGyro   0



-----------------TEAPOT TEST------------
https://github.com/jrowberg/i2cdevlib/blob/master/Arduino/MPU6050/examples/MPU6050_DMP6/MPU6050_DMP6.ino
enable TEAPOT on line 117
#define OUTPUT_TEAPOT

Download process sketch
https://raw.githubusercontent.com/jrowberg/i2cdevlib/master/Arduino/MPU6050/examples/MPU6050_DMP6/Processing/MPUTeapot/MPUTeapot.pde

Launch & Watch
Teapot (a plane actually on this release) is using the DMP Quaternion

----------------------
MAG CALIBRATION 
Magnetometer
https://github.com/kriswiner/MPU6050/wiki/Simple-and-Effective-Magnetometer-Calibration

Made sketch MPU9250-ROS-MAGCAL
based on 
https://github.com/kriswiner/ESP8285/blob/master/MPU9250/MPU9250_MS5637_BasicAHRS2_ESP8266.ino

----------------------
ROS CALIBRATION
http://wiki.ros.org/razor_imu_9dof
razor & process & python

https://www.i2cdevlib.com/forums/topic/91-how-to-decide-gyro-and-accelerometer-offsett/
What I do to get calibration values using Arduino is the following:

- Put the MPU6050 in a flat and horizontal surface. Use an inclinometer to check that it is as horizontal as possible.
- Modify the RAW program to put every offset to 0. ("setXGyroOffset/setYGyroOffset/setZGyroOffset/setZAccelOffset"  =0 ).
- Upload the RAW program to your arduino and open serial monitor so you can see the values it is returning.
- Leave it operating for a few minutes (5-10) so temperature gets stabilized.
- Check the values in the serial monitor and write them down.
- Now modify your program again updating your offsets and run the sketch, with updated offsets.
- Repeat this process until your program is returning 0 for every gyro, 0 for X and Y accel, and +16384 for Z accel.

Once you achieve this, those are the offsets for that MPU6050, you will have to repeat this for every MPU6050 you use.

*NOTES:
- If you stop the sketch for a while, sensor's temperature will get lower. If you only stop it to reprogram new offsets, you dont need to wait those 5-10 minutes every time.
- What you should try to achieve is to get the average of every gyro and XY accel to those values mentioned, so it is best if you modify the sketch to take, for example, 10000 measures, and just show on the serial monitor the average, because there is always some noise.
- It is not so straigthforward to update your offset every time. In my case, I had to put my initial readings, negated (change sign) and divided by 4 (gyros) and by 7.8 (accels).



======================================================================================
Adding Time and TF == Added this code to MPU9250_ROS
http://wiki.ros.org/rosserial_arduino/Tutorials/Time%20and%20TF

Looking at topic:
rostopic echo /tf
rosrun tf tf_echo odom base_link


============DRIFTING !!!!!==========
https://www.i2cdevlib.com/forums/topic/91-how-to-decide-gyro-and-accelerometer-offsett/
This sketch uses DMP and Output data in YAw pitch Roll or other formats. waits 20 seconds for stability before giving data.
MPU6050_auto_calibration_output_yaw_pitch_roll.ino
Good... but sitll based on the same library....




==================CLIPPING  14 Avril===================
Spurious accel signal is bad == Clip It 

https://stackoverflow.com/questions/9323903/most-efficient-elegant-way-to-clip-a-number
Answer 20 Why rewrite something that's already been written for you?
#include <boost/algorithm/clamp.hpp>
boost::algorithm::clamp(n, lower, upper)


Added  Boost to /home/patrick/catkin_ws/src/mpu6050_serial_to_imu/CMakeLists.txt
# include_directories(include)
include_directories(
  ${catkin_INCLUDE_DIRS}
  ${Boost_INCLUDE_DIRS}
)

Added library - define & code

#include <boost/algorithm/clamp.hpp>
  using boost::algorithm::clamp;

		double min = -8.0;
		double max = 8.0;
                double gxf = clamp ((gx * (4000.0/65536.0) * (M_PI/180.0) * 22.0), min, max);
                double gyf = clamp ((gy * (4000.0/65536.0) * (M_PI/180.0) * 22.0), min, max);
                double gzf = clamp ((gz * (4000.0/65536.0) * (M_PI/180.0) * 22.0), min, max);

============================OLD EXPERIMENTS & REFERENCES======================================================
SEND FULL IMU QUATERNION with TEENSY 3.2
This one works fine and I extended to Teensy 3.2  by modifying the ROS SROS camera mvBlueFox and IMU MU6050 synchronization
The Arduino will calculate precise (millisecond) timestamps for each IMU measurement (200 Hz). 
At certain timestamps (20 Hz), it will trigger the camera (via the trigger line) to capture a new image.
http://grauonline.de/wordpress/?page_id=1951
erial Library
Arduino MPU9250 connection with rosserial communication
https://github.com/kriswiner/MPU9250/blob/master/MPU9250BasicAHRS_t3.ino

This one works fine and I extended to Teensy 3.2  by modifying the ROS Serial Library
Arduino MPU9250 connection with rosserial communication
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Notes:
http://wiki.ros.org/rosserial_arduino/Tutorials/Arduino%20IDE%20Setup
sudo apt-get install -y arduino ros-indigo-rosserial-arduino ros-indigo-rosserial
cd ~/sketchbook/libraries
mv ros_lib ~/ros_lib_backup
rosrun rosserial_arduino make_libraries.py ~/sketchbook/libraries

Roserial mod for teensyLC (MKL26Z64)
/home/patrick/Arduino/libraries/ros_lib/ArduinoHardware.h
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MKL26Z64__)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Added Correct IMU Messages in:/home/patrick/Arduino/MPU9250-ROS-IMU-TF
Note: need to reduce loop so not to get checksum errors @ line 579
delay(20); 

CANNOT GET HIGHER THAN 70 HZ..... 
==================================================
RVIZ
install sudo apt-get install ros-indigo-imu-tools

LOAD
~/catkin_ws$ rosrun rviz rviz -d IMU.rviz

  ~/imu.rviz
      Enabled: true
      Name: Imu
      Topic: /imu_msg
      Unreliable: false
      Value: true
      fixed_frame_orientation: true
====================================================================================
Visual-Inertial-Odometry-On-A-Budget
ROS package to handle a VIO setup based on uEye1226 and MPU6050 == NO  CAMERA SYNC
https://riccardogiubilato.github.io/visual/odometry/2017/12/12/Visual-Inertial-Odometry-On-A-Budget.html
https://github.com/RiccardoGiubilato/tinyIMU_arduino
https://github.com/RiccardoGiubilato/cam_imu
https://github.com/jrowberg/i2cdevlib 


========================================================================
A simple package to use RTIMULib 
https://github.com/romainreignier/rtimulib_ros
https://github.com/RTIMULib/RTIMULib
https://github.com/RTIMULib/RTIMULib2
RTIMULib2 has been extended to support some other IMUs but its LINUX ONLY


This node is a ROS interface for RTIMULib2 by richards-tech,
https://github.com/jeskesen/i2c_imu
How to use mpu9250?
https://github.com/jeskesen/i2c_imu/issues/10



====================================================================================




